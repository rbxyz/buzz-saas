import { z } from "zod"
import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc"
import { db } from "@/server/db"
import { configuracoes, servicos } from "@/server/db/schema"
import { eq } from "drizzle-orm"
import { TRPCError } from "@trpc/server"

export const configuracaoRouter = createTRPCRouter({
  // Alias para compatibilidade com componentes existentes
  listar: protectedProcedure.query(async ({ ctx }) => {
    try {
      const userId = ctx.user.id;
      console.log("üîç [CONFIG-LISTAR] Buscando configura√ß√£o para userId:", userId);

      const config = await db.query.configuracoes.findFirst({
        where: eq(configuracoes.userId, userId),
      });

      console.log("üìã [CONFIG-LISTAR] Configura√ß√£o encontrada:", config ? "SIM" : "N√ÉO");

      if (!config) {
        // Retornar uma configura√ß√£o padr√£o se n√£o existir
        return {
          id: null,
          userId: userId,
          nomeEmpresa: "",
          telefone: "",
          endereco: "",
          logoUrl: "",
          corPrimaria: "#3B82F6",
          corSecundaria: "#1E40AF",
          servicos: [],
          createdAt: new Date(),
          updatedAt: new Date(),
        };
      }

      console.log("üîç [CONFIG-LISTAR] Buscando servi√ßos para userId:", userId);
      const servicosUsuario = await db.query.servicos.findMany({
        where: eq(servicos.userId, userId),
        orderBy: (servicos, { asc }) => [asc(servicos.nome)],
      });

      console.log("üì¶ [CONFIG-LISTAR] Servi√ßos encontrados:", servicosUsuario.length, servicosUsuario);

      const servicosFormatados = servicosUsuario.map((servico) => ({
        nome: servico.nome,
        preco: Number.parseFloat(servico.preco?.toString() ?? "0"),
        duracaoMinutos: servico.duracao,
      }));

      console.log("‚úÖ [CONFIG-LISTAR] Servi√ßos formatados:", servicosFormatados);

      return {
        ...config,
        servicos: servicosFormatados,
      };
    } catch (error) {
      console.error("‚ùå [CONFIG-LISTAR] Erro ao listar configura√ß√£o:", error);
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Erro ao listar sua configura√ß√£o",
      });
    }
  }),

  obterConfiguracaoCompleta: protectedProcedure.query(async ({ ctx }) => {
    try {
      const userId = ctx.user.id
      console.log("üîç [CONFIG] Buscando configura√ß√£o para userId:", userId)

      const config = await db.query.configuracoes.findFirst({
        where: eq(configuracoes.userId, userId),
      })

      console.log("üìã [CONFIG] Configura√ß√£o encontrada:", config ? "SIM" : "N√ÉO")

      if (!config) {
        // Retornar uma configura√ß√£o padr√£o se n√£o existir, j√° associada ao usu√°rio
        return {
          id: null,
          userId: userId,
          nomeEmpresa: "",
          telefone: "",
          endereco: "",
          logoUrl: "",
          corPrimaria: "#3B82F6",
          corSecundaria: "#1E40AF",
          servicos: [],
          createdAt: new Date(),
          updatedAt: new Date(),
        }
      }

      console.log("üîç [CONFIG] Buscando servi√ßos para userId:", userId)
      const servicosUsuario = await db.query.servicos.findMany({
        where: eq(servicos.userId, userId),
        orderBy: (servicos, { asc }) => [asc(servicos.nome)],
      })

      console.log("üì¶ [CONFIG] Servi√ßos encontrados:", servicosUsuario.length, servicosUsuario)

      const servicosFormatados = servicosUsuario.map((servico) => ({
        nome: servico.nome,
        preco: Number.parseFloat(servico.preco?.toString() ?? "0"),
        duracaoMinutos: servico.duracao,
      }))

      console.log("‚úÖ [CONFIG] Servi√ßos formatados:", servicosFormatados)

      return {
        ...config,
        servicos: servicosFormatados,
      }
    } catch (error) {
      console.error("‚ùå [CONFIGURACAO] Erro ao obter configura√ß√£o:", error)
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Erro ao obter sua configura√ß√£o",
      })
    }
  }),

  verificarConfiguracaoInicial: protectedProcedure.query(async ({ ctx }) => {
    try {
      const userId = ctx.user.id

      const config = await db.query.configuracoes.findFirst({
        where: eq(configuracoes.userId, userId),
      })

      if (!config) {
        return {
          configuracaoInicialCompleta: false,
          camposFaltantes: ['nome da empresa', 'telefone', 'endere√ßo'],
          mensagem: "Configure as informa√ß√µes b√°sicas do seu estabelecimento para come√ßar a usar o sistema."
        }
      }

      const camposFaltantes: string[] = []

      if (!config.nomeEmpresa || config.nomeEmpresa.trim() === '') {
        camposFaltantes.push('nome da empresa')
      }

      if (!config.telefone || config.telefone.trim() === '') {
        camposFaltantes.push('telefone')
      }

      if (!config.endereco || config.endereco.trim() === '') {
        camposFaltantes.push('endere√ßo')
      }

      return {
        configuracaoInicialCompleta: camposFaltantes.length === 0,
        camposFaltantes,
        mensagem: camposFaltantes.length > 0
          ? `Para completar a configura√ß√£o, preencha: ${camposFaltantes.join(', ')}.`
          : "Configura√ß√£o inicial completa!"
      }
    } catch (error) {
      console.error("‚ùå [CONFIGURACAO] Erro ao verificar configura√ß√£o inicial:", error)
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Erro ao verificar configura√ß√£o inicial",
      })
    }
  }),

  atualizarConfiguracao: protectedProcedure
    .input(
      z.object({
        nomeEmpresa: z.string().optional(),
        telefone: z.string().optional(),
        endereco: z.string().optional(),
        logoUrl: z.string().optional(),
        corPrimaria: z.string().optional(),
        corSecundaria: z.string().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.user.id

      // Verificar se √© a primeira configura√ß√£o (configura√ß√£o inicial)
      const existingConfig = await db.query.configuracoes.findFirst({
        where: eq(configuracoes.userId, userId),
      })

      const isFirstTimeSetup = !existingConfig

      // Valida√ß√£o espec√≠fica para configura√ß√£o inicial
      if (isFirstTimeSetup) {
        const missingFields: string[] = []

        if (!input.nomeEmpresa || input.nomeEmpresa.trim() === '') {
          missingFields.push('nome da empresa')
        }

        if (!input.telefone || input.telefone.trim() === '') {
          missingFields.push('telefone')
        }

        if (!input.endereco || input.endereco.trim() === '') {
          missingFields.push('endere√ßo')
        }

        if (missingFields.length > 0) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: `Para completar a configura√ß√£o inicial, preencha os seguintes campos: ${missingFields.join(', ')}.`,
          })
        }
      }

      // Valida√ß√£o para atualiza√ß√µes (nome da empresa sempre obrigat√≥rio)
      if (!isFirstTimeSetup && (!input.nomeEmpresa || input.nomeEmpresa.trim() === '')) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "O nome da empresa √© obrigat√≥rio.",
        })
      }

      if (existingConfig) {
        await db
          .update(configuracoes)
          .set({ ...input, updatedAt: new Date() })
          .where(eq(configuracoes.userId, userId))
      } else {
        await db.insert(configuracoes).values({ ...input, userId })
      }

      return {
        success: true,
        message: isFirstTimeSetup
          ? "Configura√ß√£o inicial conclu√≠da com sucesso!"
          : "Configura√ß√µes da conta salvas."
      }
    }),



  updateServicos: protectedProcedure
    .input(
      z.array(
        z.object({
          nome: z.string(),
          preco: z.number(),
          duracaoMinutos: z.number(),
        }),
      ),
    )
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.user.id;

      // 1. Deletar todos os servi√ßos existentes para este usu√°rio
      await db.delete(servicos).where(eq(servicos.userId, userId));

      // 2. Inserir os novos servi√ßos
      if (input.length > 0) {
        const servicosParaInserir = input.map((s) => ({
          userId,
          nome: s.nome,
          preco: s.preco.toString(),
          duracao: s.duracaoMinutos,
          ativo: true,
        }));
        await db.insert(servicos).values(servicosParaInserir);
      }

      return { success: true, message: "Lista de servi√ßos atualizada." };
    }),
})
