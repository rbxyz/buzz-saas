import { groq } from "@ai-sdk/groq"
import { generateText } from "ai"
import { db } from "@/server/db"
import { conversations, messages } from "@/server/db/schema"
import { eq, desc } from "drizzle-orm"
import dayjs from "dayjs"
import "dayjs/locale/pt-br"

dayjs.locale("pt-br")

interface ServicoConfigurado {
  nome: string
  preco: number
  duracaoMinutos: number
}

interface AgendamentoContext {
  servicos: ServicoConfigurado[]
  configuracao: any
  cliente?: any
  agendamentos?: any[]
  conversationHistory: Array<{ role: string; content: string }>
  // Novo: contexto de agendamento em andamento
  agendamentoEmAndamento?: {
    servico?: string
    data?: string
    horario?: string
  }
}

interface AIResponse {
  message: string
  action?:
    | "agendar_direto"
    | "verificar_horario"
    | "listar_servicos"
    | "listar_horarios"
    | "cancelar"
    | "reagendar"
    | "consultar_agendamentos"
  data?: any
}

export class AIService {
  private model = groq("llama-3.1-8b-instant")
  private baseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"

  // Armazenar contexto de agendamento entre mensagens
  private agendamentoContexto: Record<
    string,
    {
      servico?: string
      data?: string
      horario?: string
      ultimaAtualizacao: Date
    }
  > = {}

  // Rastrear se j√° foi feita a sauda√ß√£o inicial para cada telefone
  private saudacoesFeitas: Set<string> = new Set()

  async processMessage(
    message: string,
    telefone: string,
    conversationHistory: Array<{ role: string; content: string }> = [],
  ): Promise<AIResponse> {
    try {
      console.log(`üß† [AI-SERVICE] Processando mensagem: "${message}"`)
      console.log(`üì± [AI-SERVICE] Telefone do cliente: ${telefone}`)

      // Verificar se √© a primeira mensagem desta conversa
      const isPrimeiraMensagem = this.isPrimeiraMensagemDaConversa(telefone, conversationHistory)
      console.log(`üëã [AI-SERVICE] √â primeira mensagem? ${isPrimeiraMensagem}`)

      // Buscar contexto completo via webhooks
      const context = await this.getBusinessContext(telefone)

      // Adicionar contexto de agendamento em andamento
      if (this.agendamentoContexto[telefone]) {
        // Verificar se o contexto n√£o est√° expirado (30 minutos)
        const agora = new Date()
        const ultimaAtualizacao = this.agendamentoContexto[telefone].ultimaAtualizacao
        const diferencaMinutos = (agora.getTime() - ultimaAtualizacao.getTime()) / (1000 * 60)

        if (diferencaMinutos < 30) {
          context.agendamentoEmAndamento = this.agendamentoContexto[telefone]
          console.log(`üîÑ [AI-SERVICE] Recuperando contexto de agendamento:`, context.agendamentoEmAndamento)
        } else {
          // Contexto expirado
          delete this.agendamentoContexto[telefone]
        }
      }

      // Se √© primeira mensagem, personalizar sauda√ß√£o
      if (isPrimeiraMensagem) {
        const saudacaoPersonalizada = await this.criarSaudacaoPersonalizada(context.cliente, message)
        if (saudacaoPersonalizada) {
          console.log(`üëã [AI-SERVICE] Enviando sauda√ß√£o personalizada`)
          // Marcar que a sauda√ß√£o foi feita
          this.saudacoesFeitas.add(telefone)
          return { message: saudacaoPersonalizada }
        }
      }

      if (context.cliente) {
        console.log(`üë§ [AI-SERVICE] Cliente encontrado: ${context.cliente.nome} (ID: ${context.cliente.id})`)
      } else {
        console.log(`üÜï [AI-SERVICE] Cliente n√£o encontrado para o telefone ${telefone}`)
      }

      console.log(`üìä [AI-SERVICE] Servi√ßos carregados: ${context.servicos.length}`)
      console.log(`üìä [AI-SERVICE] Hist√≥rico: ${context.conversationHistory.length} mensagens`)

      // Criar prompt do sistema personalizado
      const systemPrompt = this.createPersonalizedSystemPrompt(context)

      // Preparar mensagens para a IA
      const messages = [
        { role: "system", content: systemPrompt },
        ...context.conversationHistory.slice(-10),
        { role: "user", content: message },
      ]

      console.log(`ü§ñ [AI-SERVICE] Enviando para IA: ${messages.length} mensagens`)

      // Gerar resposta da IA
      const result = await generateText({
        model: this.model,
        messages,
        temperature: 0.9,
        maxTokens: 1200,
      })

      console.log(`‚úÖ [AI-SERVICE] Resposta recebida (${result.text.length} chars)`)

      // Analisar e processar a resposta
      const aiResponse = await this.parseAndProcessResponse(result.text, message, telefone, context)

      return aiResponse
    } catch (error) {
      console.error("üí• [AI-SERVICE] Erro no processamento da IA:", error)
      return {
        message:
          "Oi! Desculpa, tive um probleminha aqui. üòÖ Pode repetir o que voc√™ precisa? Estou aqui pra te ajudar! üíà",
      }
    }
  }

  private async getBusinessContext(telefone: string): Promise<AgendamentoContext> {
    try {
      console.log(`üîç [AI-SERVICE] Buscando contexto via webhooks para: ${telefone}`)

      // Limpar telefone
      const telefoneClean = telefone.replace(/\D/g, "")

      // 1. Buscar servi√ßos e configura√ß√£o
      const servicosResponse = await fetch(`${this.baseUrl}/api/webhooks/listar-servicos`)
      const servicosData = await servicosResponse.json()

      if (!servicosData.success) {
        throw new Error("Erro ao buscar servi√ßos")
      }

      // 2. Buscar cliente e agendamentos
      const clienteResponse = await fetch(`${this.baseUrl}/api/webhooks/buscar-cliente?telefone=${telefoneClean}`)
      const clienteData = await clienteResponse.json()

      if (!clienteData.success) {
        throw new Error("Erro ao buscar cliente")
      }

      // 3. Buscar hist√≥rico da conversa
      const conversation = await db
        .select()
        .from(conversations)
        .where(eq(conversations.telefone, telefoneClean))
        .limit(1)
        .then((rows) => rows[0] || null)

      let conversationHistory: Array<{ role: string; content: string }> = []

      if (conversation) {
        const dbMessages = await db
          .select()
          .from(messages)
          .where(eq(messages.conversationId, conversation.id))
          .orderBy(desc(messages.createdAt))
          .limit(20)

        conversationHistory = dbMessages.reverse().map((msg) => ({
          role: msg.remetente === "cliente" ? "user" : "assistant",
          content: msg.conteudo,
        }))
      }

      console.log(`‚úÖ [AI-SERVICE] Contexto carregado via webhooks:`, {
        servicos: servicosData.servicos.length,
        cliente: clienteData.cliente?.nome || "N√£o encontrado",
        agendamentos: clienteData.agendamentos.length,
        historico: conversationHistory.length,
      })

      return {
        servicos: servicosData.servicos,
        configuracao: servicosData.configuracao,
        cliente: clienteData.cliente,
        agendamentos: clienteData.agendamentos,
        conversationHistory,
      }
    } catch (error) {
      console.error("üí• [AI-SERVICE] Erro ao buscar contexto:", error)
      return {
        servicos: [
          { nome: "Corte", preco: 25.0, duracaoMinutos: 30 },
          { nome: "Barba", preco: 15.0, duracaoMinutos: 20 },
          { nome: "Corte + Barba", preco: 35.0, duracaoMinutos: 45 },
        ],
        configuracao: null,
        conversationHistory: [],
      }
    }
  }

  private createPersonalizedSystemPrompt(context: AgendamentoContext): string {
    const { servicos, configuracao, cliente, agendamentos, conversationHistory, agendamentoEmAndamento } = context

    const servicosTexto = servicos
      .map((s) => `‚Ä¢ ${s.nome}: R$ ${s.preco.toFixed(2)} (${s.duracaoMinutos} min)`)
      .join("\n")

    const clienteInfo = cliente
      ? `Cliente conhecido: ${cliente.nome} (telefone: ${cliente.telefone})`
      : "Cliente novo (precisa perguntar o nome para cadastro)"

    const agendamentosInfo =
      agendamentos && agendamentos.length > 0
        ? `Cliente tem ${agendamentos.length} agendamentos anteriores`
        : "Cliente n√£o tem agendamentos anteriores"

    const historicoInfo =
      conversationHistory.length > 0
        ? `Hist√≥rico da conversa: ${conversationHistory.length} mensagens anteriores`
        : "Primeira intera√ß√£o com este cliente"

    // Informa√ß√µes sobre agendamento em andamento
    let agendamentoEmAndamentoInfo = ""
    if (agendamentoEmAndamento) {
      agendamentoEmAndamentoInfo = `
üîÑ **AGENDAMENTO EM ANDAMENTO:**
${agendamentoEmAndamento.servico ? `‚Ä¢ Servi√ßo: ${agendamentoEmAndamento.servico}` : "‚Ä¢ Servi√ßo: n√£o informado"}
${agendamentoEmAndamento.data ? `‚Ä¢ Data: ${agendamentoEmAndamento.data}` : "‚Ä¢ Data: n√£o informada"}
${agendamentoEmAndamento.horario ? `‚Ä¢ Hor√°rio: ${agendamentoEmAndamento.horario}` : "‚Ä¢ Hor√°rio: n√£o informado"}
`
    }

    return `Voc√™ √© o assistente virtual da ${configuracao?.nome || "Barbearia do Ruan"}.

üéØ **SUA PERSONALIDADE:**
- Seja CORDIAL, AMIG√ÅVEL e NATURAL como uma pessoa real
- Use linguagem brasileira informal mas respeitosa
- Seja SUCINTO mas completo nas respostas
- Demonstre interesse genu√≠no em ajudar
- Lembre-se sempre do contexto da conversa

üè™ **INFORMA√á√ïES DO NEG√ìCIO:**
- Nome: ${configuracao?.nome || "Barbearia do Ruan"}
- Telefone: ${configuracao?.telefone || "(51) 98761-4130"}
- Endere√ßo: ${configuracao?.endereco || "Rua Principal, 123"}
- Hor√°rio: ${configuracao?.horaInicio || "09:00"} √†s ${configuracao?.horaFim || "18:00"}

üíà **SERVI√áOS DISPON√çVEIS:**
${servicosTexto}

üë§ **CLIENTE ATUAL:**
${clienteInfo}
${agendamentosInfo}
${agendamentoEmAndamentoInfo}

üìù **CONTEXTO DA CONVERSA:**
${historicoInfo}

üéØ **SUAS RESPONSABILIDADES:**
1. **Cumprimentar** de forma calorosa na primeira mensagem
2. **Lembrar** do contexto das mensagens anteriores
3. **Perguntar o nome** se for cliente novo (MUITO IMPORTANTE)
4. **Verificar disponibilidade** antes de agendar
5. **Agendar AUTOMATICAMENTE** quando tiver: nome, servi√ßo, data e hor√°rio dispon√≠vel
6. **Perguntar** de forma natural o que falta para agendar
7. **Ser proativo** em sugerir hor√°rios e servi√ßos

üí¨ **COMO CONVERSAR:**
- Use "oi", "ol√°", "tudo bem?" naturalmente
- Fa√ßa perguntas abertas: "O que voc√™ precisa hoje?"
- Seja emp√°tico: "Entendi!", "Perfeito!", "√ìtima escolha!"
- Use emojis com modera√ß√£o: üòä üíà ‚úÖ üìÖ

‚ö†Ô∏è **IMPORTANTE PARA NOVOS CLIENTES:**
- Se o cliente n√£o estiver cadastrado, SEMPRE pergunte o nome completo
- Explique que o nome √© necess√°rio para o cadastro
- S√≥ prossiga com agendamento ap√≥s ter o nome

üîß **A√á√ïES OBRIGAT√ìRIAS - USE SEMPRE QUE NECESS√ÅRIO:**

**PARA LISTAR SERVI√áOS:**
- Quando cliente perguntar sobre servi√ßos, pre√ßos ou o que voc√™s fazem
- SEMPRE responda com: "WEBHOOK:listar_servicos"
- Exemplo: Cliente: "Quais servi√ßos voc√™s fazem?" ‚Üí Voc√™: "WEBHOOK:listar_servicos"

**PARA AGENDAR:**
- Quando tiver TODOS os dados (nome, servi√ßo, data, hor√°rio)
- SEMPRE use: "WEBHOOK:criar_agendamento"
- Exemplo: "Jo√£o quer corte para 24/06 √†s 10h" ‚Üí "WEBHOOK:criar_agendamento"

**PARA VERIFICAR HOR√ÅRIOS:**
- Quando cliente perguntar hor√°rios dispon√≠veis
- SEMPRE use: "WEBHOOK:listar_horarios"
- Exemplo: "Que hor√°rios t√™m para amanh√£?" ‚Üí "WEBHOOK:listar_horarios"

**PARA VERIFICAR DISPONIBILIDADE:**
- Antes de confirmar qualquer agendamento
- SEMPRE use: "WEBHOOK:verificar_disponibilidade"
- Exemplo: Antes de agendar ‚Üí "WEBHOOK:verificar_disponibilidade"

**PARA CONSULTAR AGENDAMENTOS:**
- Quando cliente perguntar sobre seus agendamentos
- SEMPRE use: "WEBHOOK:consultar_agendamentos"
- Exemplo: "Quais s√£o meus agendamentos?" ‚Üí "WEBHOOK:consultar_agendamentos"

üìã **EXEMPLOS PR√ÅTICOS:**

Cliente: "Quais servi√ßos voc√™s fazem?"
Voc√™: "WEBHOOK:listar_servicos"

Cliente: "Quero agendar um corte para amanh√£ √†s 14h"
Voc√™: "WEBHOOK:verificar_disponibilidade" (primeiro verificar)
Se dispon√≠vel: "WEBHOOK:criar_agendamento"

Cliente: "Que hor√°rios t√™m para segunda?"
Voc√™: "WEBHOOK:listar_horarios"

Cliente: "Quais s√£o meus agendamentos?"
Voc√™: "WEBHOOK:consultar_agendamentos"

‚ö†Ô∏è **REGRAS CR√çTICAS:**
- NUNCA invente informa√ß√µes sobre servi√ßos - SEMPRE use WEBHOOK:listar_servicos
- NUNCA confirme agendamento sem usar WEBHOOK:verificar_disponibilidade
- NUNCA liste hor√°rios sem usar WEBHOOK:listar_horarios
- SEMPRE use os webhooks para qualquer consulta ou a√ß√£o
- Se n√£o souber algo, use o webhook apropriado

üö® **IMPORTANTE:**
- Toda vez que precisar de informa√ß√µes do sistema, use WEBHOOK:(a√ß√£o)
- N√£o invente respostas - sempre consulte via webhook
- Os webhooks s√£o sua fonte de verdade para tudo`
  }

  private async parseAndProcessResponse(
    aiText: string,
    userMessage: string,
    telefone: string,
    context: AgendamentoContext,
  ): Promise<AIResponse> {
    console.log(`üîç [AI-SERVICE] Analisando resposta da IA: "${aiText}"`)
    console.log(`üîç [AI-SERVICE] Mensagem do usu√°rio: "${userMessage}"`)

    const lowerMessage = userMessage.toLowerCase()
    const lowerAI = aiText.toLowerCase()

    // Extrair dados da mensagem atual
    const dadosExtraidos = await this.extractAppointmentData(userMessage, context)

    // Atualizar contexto de agendamento com os dados extra√≠dos
    this.atualizarContextoAgendamento(telefone, dadosExtraidos)

    // Combinar dados extra√≠dos com contexto de agendamento
    const dadosAgendamento = this.combinarDadosComContexto(dadosExtraidos, telefone)
    console.log(`üìã [AI-SERVICE] Dados combinados para agendamento:`, dadosAgendamento)

    // 1. DETECTAR WEBHOOKS EXPL√çCITOS NA RESPOSTA DA IA
    if (lowerAI.includes("webhook:listar_servicos")) {
      console.log(`üéØ [AI-SERVICE] Detectado: WEBHOOK:listar_servicos`)
      const servicosTexto = this.formatarServicosNatural(context.servicos)
      return { message: servicosTexto, action: "listar_servicos" }
    }

    if (lowerAI.includes("webhook:listar_horarios")) {
      console.log(`üéØ [AI-SERVICE] Detectado: WEBHOOK:listar_horarios`)
      const dataExtraida = dadosAgendamento.data || dayjs().format("YYYY-MM-DD")
      const horariosTexto = await this.formatarHorariosDisponiveisViaWebhook(
        dataExtraida,
        context.servicos[0]?.nome || "Corte",
      )
      return { message: horariosTexto, action: "listar_horarios", data: { data: dataExtraida } }
    }

    if (lowerAI.includes("webhook:consultar_agendamentos")) {
      console.log(`üéØ [AI-SERVICE] Detectado: WEBHOOK:consultar_agendamentos`)
      const agendamentosTexto = this.formatarAgendamentosNatural(context.agendamentos || [])
      return { message: agendamentosTexto, action: "consultar_agendamentos" }
    }

    if (lowerAI.includes("webhook:criar_agendamento")) {
      console.log(`üéØ [AI-SERVICE] Detectado: WEBHOOK:criar_agendamento`)

      // Se n√£o temos o nome e n√£o √© cliente cadastrado, precisamos perguntar
      if (!dadosAgendamento.nome && !context.cliente) {
        console.log(`‚ùå [AI-SERVICE] Nome n√£o encontrado e cliente n√£o cadastrado`)
        return {
          message: "Oi! Para fazer seu agendamento, preciso saber seu nome completo, por favor! üòä",
        }
      }

      // Usar nome do cliente cadastrado se n√£o tiver na mensagem
      if (!dadosAgendamento.nome && context.cliente) {
        dadosAgendamento.nome = context.cliente.nome
      }

      if (dadosAgendamento.servico && dadosAgendamento.data && dadosAgendamento.horario) {
        console.log(`‚è≥ [AI-SERVICE] Verificando disponibilidade via webhook:`, dadosAgendamento)

        // Verificar disponibilidade via webhook
        const verificacao = await this.verificarDisponibilidadeViaWebhook({
          data: dadosAgendamento.data,
          horario: dadosAgendamento.horario,
          servico: dadosAgendamento.servico,
        })

        if (verificacao.disponivel) {
          // Hor√°rio dispon√≠vel, criar agendamento via webhook
          console.log(`‚úÖ [AI-SERVICE] Hor√°rio dispon√≠vel, criando agendamento via webhook`)

          const resultado = await this.criarAgendamentoViaWebhook({
            telefone,
            nome: dadosAgendamento.nome,
            servico: dadosAgendamento.servico,
            data: dadosAgendamento.data,
            horario: dadosAgendamento.horario,
          })

          // Limpar contexto de agendamento ap√≥s sucesso
          if (resultado.success) {
            delete this.agendamentoContexto[telefone]
          }

          return {
            message: resultado.message,
            action: "agendar_direto",
            data: resultado,
          }
        } else {
          // Hor√°rio n√£o dispon√≠vel, sugerir alternativas
          console.log(`‚ùå [AI-SERVICE] Hor√°rio n√£o dispon√≠vel:`, verificacao.motivo)

          let mensagemIndisponivel = `Ops! O hor√°rio ${dadosAgendamento.horario} do dia ${dayjs(dadosAgendamento.data).format("DD/MM")} n√£o est√° dispon√≠vel. üòÖ\n\n`

          if (verificacao.horariosAlternativos && verificacao.horariosAlternativos.length > 0) {
            mensagemIndisponivel += `**Hor√°rios dispon√≠veis para o mesmo dia:**\n`
            verificacao.horariosAlternativos.forEach((horario) => {
              mensagemIndisponivel += `‚Ä¢ ${horario}\n`
            })
            mensagemIndisponivel += `\nQual desses hor√°rios te atende melhor? üòä`
          } else {
            mensagemIndisponivel += `Infelizmente n√£o temos outros hor√°rios dispon√≠veis neste dia. Que tal escolher outro dia? üìÖ`
          }

          return {
            message: mensagemIndisponivel,
            action: "verificar_horario",
            data: { verificacao, dadosAgendamento },
          }
        }
      } else {
        // Perguntar o que falta de forma natural
        const pergunta = this.createNaturalQuestion(dadosAgendamento)
        return { message: pergunta }
      }
    }

    if (lowerAI.includes("webhook:verificar_disponibilidade")) {
      console.log(`üéØ [AI-SERVICE] Detectado: WEBHOOK:verificar_disponibilidade`)

      if (dadosAgendamento.servico && dadosAgendamento.data && dadosAgendamento.horario) {
        console.log(`‚è≥ [AI-SERVICE] Verificando disponibilidade via webhook:`, dadosAgendamento)

        // Verificar disponibilidade via webhook
        const verificacao = await this.verificarDisponibilidadeViaWebhook({
          data: dadosAgendamento.data,
          horario: dadosAgendamento.horario,
          servico: dadosAgendamento.servico,
        })

        if (verificacao.disponivel) {
          return {
            message: `‚úÖ Hor√°rio dispon√≠vel! O hor√°rio ${dadosAgendamento.horario} do dia ${dayjs(dadosAgendamento.data).format("DD/MM")} est√° dispon√≠vel para ${dadosAgendamento.servico}.\n\nDeseja confirmar o agendamento?`,
            action: "verificar_horario",
            data: { verificacao, dadosAgendamento },
          }
        } else {
          // Hor√°rio n√£o dispon√≠vel, sugerir alternativas
          console.log(`‚ùå [AI-SERVICE] Hor√°rio n√£o dispon√≠vel:`, verificacao.motivo)

          let mensagemIndisponivel = `Ops! O hor√°rio ${dadosAgendamento.horario} do dia ${dayjs(dadosAgendamento.data).format("DD/MM")} n√£o est√° dispon√≠vel. üòÖ\n\n`

          if (verificacao.horariosAlternativos && verificacao.horariosAlternativos.length > 0) {
            mensagemIndisponivel += `**Hor√°rios dispon√≠veis para o mesmo dia:**\n`
            verificacao.horariosAlternativos.forEach((horario) => {
              mensagemIndisponivel += `‚Ä¢ ${horario}\n`
            })
            mensagemIndisponivel += `\nQual desses hor√°rios te atende melhor? üòä`
          } else {
            mensagemIndisponivel += `Infelizmente n√£o temos outros hor√°rios dispon√≠veis neste dia. Que tal escolher outro dia? üìÖ`
          }

          return {
            message: mensagemIndisponivel,
            action: "verificar_horario",
            data: { verificacao, dadosAgendamento },
          }
        }
      } else {
        // Perguntar o que falta de forma natural
        const pergunta = this.createNaturalQuestion(dadosAgendamento)
        return { message: pergunta }
      }
    }

    // 2. DETECTAR INTEN√á√ïES NA MENSAGEM DO USU√ÅRIO (fallback)

    // Listar servi√ßos
    if (
      lowerMessage.includes("servi√ßos") ||
      lowerMessage.includes("servicos") ||
      lowerMessage.includes("pre√ßo") ||
      lowerMessage.includes("preco") ||
      lowerMessage.includes("quanto custa") ||
      lowerMessage.includes("o que voc√™s fazem") ||
      lowerMessage.includes("que servi√ßos")
    ) {
      console.log(`üéØ [AI-SERVICE] Detectado na mensagem: LISTAR SERVI√áOS`)
      const servicosTexto = this.formatarServicosNatural(context.servicos)
      return { message: servicosTexto, action: "listar_servicos" }
    }

    // Listar hor√°rios
    if (
      lowerMessage.includes("hor√°rios") ||
      lowerMessage.includes("horarios") ||
      lowerMessage.includes("que horas") ||
      lowerMessage.includes("hor√°rio") ||
      lowerMessage.includes("horario") ||
      lowerMessage.includes("dispon√≠vel")
    ) {
      console.log(`üéØ [AI-SERVICE] Detectado na mensagem: LISTAR HOR√ÅRIOS`)
      const dataExtraida = dadosAgendamento.data || dayjs().format("YYYY-MM-DD")
      const horariosTexto = await this.formatarHorariosDisponiveisViaWebhook(
        dataExtraida,
        context.servicos[0]?.nome || "Corte",
      )
      return { message: horariosTexto, action: "listar_horarios", data: { data: dataExtraida } }
    }

    // Detectar agendamento
    if (
      this.shouldCreateAppointmentDirectly(userMessage, context) ||
      (dadosAgendamento.servico && dadosAgendamento.data && dadosAgendamento.horario)
    ) {
      console.log(`üéØ [AI-SERVICE] Detectado na mensagem: AGENDAMENTO`)

      // Se n√£o temos o nome e n√£o √© cliente cadastrado, precisamos perguntar
      if (!dadosAgendamento.nome && !context.cliente) {
        console.log(`‚ùå [AI-SERVICE] Nome n√£o encontrado e cliente n√£o cadastrado`)
        return {
          message: "Oi! Para fazer seu agendamento, preciso saber seu nome completo, por favor! üòä",
        }
      }

      // Usar nome do cliente cadastrado se n√£o tiver na mensagem
      if (!dadosAgendamento.nome && context.cliente) {
        dadosAgendamento.nome = context.cliente.nome
      }

      if (dadosAgendamento.servico && dadosAgendamento.data && dadosAgendamento.horario) {
        console.log(`‚è≥ [AI-SERVICE] Verificando disponibilidade via webhook:`, dadosAgendamento)

        // Verificar disponibilidade via webhook
        const verificacao = await this.verificarDisponibilidadeViaWebhook({
          data: dadosAgendamento.data,
          horario: dadosAgendamento.horario,
          servico: dadosAgendamento.servico,
        })

        if (verificacao.disponivel) {
          // Hor√°rio dispon√≠vel, criar agendamento via webhook
          console.log(`‚úÖ [AI-SERVICE] Hor√°rio dispon√≠vel, criando agendamento via webhook`)

          const resultado = await this.criarAgendamentoViaWebhook({
            telefone,
            nome: dadosAgendamento.nome,
            servico: dadosAgendamento.servico,
            data: dadosAgendamento.data,
            horario: dadosAgendamento.horario,
          })

          // Limpar contexto de agendamento ap√≥s sucesso
          if (resultado.success) {
            delete this.agendamentoContexto[telefone]
          }

          return {
            message: resultado.message,
            action: "agendar_direto",
            data: resultado,
          }
        } else {
          // Hor√°rio n√£o dispon√≠vel, sugerir alternativas
          console.log(`‚ùå [AI-SERVICE] Hor√°rio n√£o dispon√≠vel:`, verificacao.motivo)

          let mensagemIndisponivel = `Ops! O hor√°rio ${dadosAgendamento.horario} do dia ${dayjs(dadosAgendamento.data).format("DD/MM")} n√£o est√° dispon√≠vel. üòÖ\n\n`

          if (verificacao.horariosAlternativos && verificacao.horariosAlternativos.length > 0) {
            mensagemIndisponivel += `**Hor√°rios dispon√≠veis para o mesmo dia:**\n`
            verificacao.horariosAlternativos.forEach((horario) => {
              mensagemIndisponivel += `‚Ä¢ ${horario}\n`
            })
            mensagemIndisponivel += `\nQual desses hor√°rios te atende melhor? üòä`
          } else {
            mensagemIndisponivel += `Infelizmente n√£o temos outros hor√°rios dispon√≠veis neste dia. Que tal escolher outro dia? üìÖ`
          }

          return {
            message: mensagemIndisponivel,
            action: "verificar_horario",
            data: { verificacao, dadosAgendamento },
          }
        }
      } else {
        // Perguntar o que falta de forma natural
        const pergunta = this.createNaturalQuestion(dadosAgendamento)
        return { message: pergunta }
      }
    }

    // Consultar agendamentos
    if (
      context.cliente &&
      (lowerMessage.includes("agendamento") ||
        lowerMessage.includes("consultar") ||
        lowerMessage.includes("meus hor√°rios") ||
        lowerMessage.includes("quando tenho"))
    ) {
      console.log(`üéØ [AI-SERVICE] Detectado na mensagem: CONSULTAR AGENDAMENTOS`)
      const agendamentosTexto = this.formatarAgendamentosNatural(context.agendamentos || [])
      return { message: agendamentosTexto, action: "consultar_agendamentos" }
    }

    // 3. Resposta padr√£o da IA
    console.log(`üí¨ [AI-SERVICE] Usando resposta padr√£o da IA`)
    return { message: aiText }
  }

  private atualizarContextoAgendamento(telefone: string, dados: any) {
    // Inicializar contexto se n√£o existir
    if (!this.agendamentoContexto[telefone]) {
      this.agendamentoContexto[telefone] = {
        ultimaAtualizacao: new Date(),
      }
    }

    // Atualizar apenas os campos que foram extra√≠dos
    if (dados.servico) {
      this.agendamentoContexto[telefone].servico = dados.servico
    }

    if (dados.data) {
      this.agendamentoContexto[telefone].data = dados.data
    }

    if (dados.horario) {
      this.agendamentoContexto[telefone].horario = dados.horario
    }

    // Atualizar timestamp
    this.agendamentoContexto[telefone].ultimaAtualizacao = new Date()

    console.log(`üîÑ [AI-SERVICE] Contexto de agendamento atualizado:`, this.agendamentoContexto[telefone])
  }

  private combinarDadosComContexto(dadosExtraidos: any, telefone: string) {
    const resultado = { ...dadosExtraidos }

    // Se n√£o temos contexto, retornar apenas os dados extra√≠dos
    if (!this.agendamentoContexto[telefone]) {
      return resultado
    }

    // Combinar com contexto existente
    if (!resultado.servico && this.agendamentoContexto[telefone].servico) {
      resultado.servico = this.agendamentoContexto[telefone].servico
    }

    if (!resultado.data && this.agendamentoContexto[telefone].data) {
      resultado.data = this.agendamentoContexto[telefone].data
    }

    if (!resultado.horario && this.agendamentoContexto[telefone].horario) {
      resultado.horario = this.agendamentoContexto[telefone].horario
    }

    // Verificar se est√° completo
    resultado.completo = !!(resultado.nome && resultado.servico && resultado.data && resultado.horario)

    return resultado
  }

  private async verificarDisponibilidadeViaWebhook(dados: {
    data: string
    horario: string
    servico: string
  }) {
    try {
      console.log(`üîç [AI-SERVICE] Verificando disponibilidade via webhook:`, dados)

      const response = await fetch(`${this.baseUrl}/api/webhooks/verificar-disponibilidade`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(dados),
      })

      const result = await response.json()

      if (!result.success) {
        throw new Error(result.error)
      }

      console.log(`‚úÖ [AI-SERVICE] Verifica√ß√£o conclu√≠da:`, result)
      return result
    } catch (error) {
      console.error("üí• [AI-SERVICE] Erro ao verificar disponibilidade:", error)
      return {
        disponivel: false,
        motivo: "Erro interno",
        horariosAlternativos: [],
      }
    }
  }

  private async criarAgendamentoViaWebhook(dados: {
    telefone: string
    nome: string
    servico: string
    data: string
    horario: string
  }) {
    try {
      console.log(`üöÄ [AI-SERVICE] Criando agendamento via webhook:`, dados)

      const response = await fetch(`${this.baseUrl}/api/webhooks/criar-agendamento`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(dados),
      })

      const result = await response.json()

      if (!result.success) {
        throw new Error(result.error)
      }

      console.log(`‚úÖ [AI-SERVICE] Agendamento criado via webhook:`, result.agendamento?.id)
      return result
    } catch (error) {
      console.error("üí• [AI-SERVICE] Erro ao criar agendamento:", error)
      return {
        success: false,
        message: "Ops! Deu um probleminha aqui. üòÖ Pode tentar de novo? Ou me chama que resolvo na hora!",
      }
    }
  }

  private async formatarHorariosDisponiveisViaWebhook(data: string, servico: string): Promise<string> {
    try {
      console.log(`üìÖ [AI-SERVICE] Formatando hor√°rios via webhook para ${data}`)

      const response = await fetch(
        `${this.baseUrl}/api/webhooks/listar-horarios?data=${data}&servico=${encodeURIComponent(servico)}`,
      )
      const result = await response.json()

      if (!result.success) {
        throw new Error(result.error)
      }

      const { horariosDisponiveis, periodos, dataFormatada } = result

      if (horariosDisponiveis.length === 0) {
        return `Ops! N√£o temos hor√°rios dispon√≠veis para ${dataFormatada}. üòÖ\n\nQue tal escolher outro dia? üìÖ`
      }

      let texto = `üìÖ **Hor√°rios dispon√≠veis para ${dataFormatada}:**\n\n`

      if (periodos.manha.length > 0) {
        texto += `üåÖ **Manh√£:** ${periodos.manha.join(", ")}\n`
      }

      if (periodos.tarde.length > 0) {
        texto += `üåû **Tarde:** ${periodos.tarde.join(", ")}\n`
      }

      texto += `\nQual hor√°rio prefere? üòä`

      return texto
    } catch (error) {
      console.error("üí• [AI-SERVICE] Erro ao formatar hor√°rios:", error)
      return "Ops! N√£o consegui consultar os hor√°rios agora. Tenta de novo? üòÖ"
    }
  }

  private shouldCreateAppointmentDirectly(message: string, context: AgendamentoContext): boolean {
    const lowerMessage = message.toLowerCase()

    // Palavras que indicam inten√ß√£o de agendamento
    const agendamentoWords = ["agendar", "marcar", "quero", "gostaria", "preciso", "vou querer", "para"]
    const temIntencao = agendamentoWords.some((word) => lowerMessage.includes(word))

    // Verificar se tem dados suficientes na mensagem ou contexto
    const temServico = context.servicos.some((s) => lowerMessage.includes(s.nome.toLowerCase()))
    const temData = this.extrairData(message) !== null
    const temHorario = /\d{1,2}:?\d{0,2}/.test(message)

    console.log(`üîç [AI-SERVICE] An√°lise de agendamento:`, {
      temIntencao,
      temServico,
      temData,
      temHorario,
    })

    return temIntencao && (temServico || temData || temHorario)
  }

  private async extractAppointmentData(message: string, context: AgendamentoContext) {
    const dados = {
      nome: context.cliente?.nome || this.extrairNome(message),
      servico: this.extrairServico(message, context.servicos),
      data: this.extrairData(message),
      horario: this.extrairHorario(message),
      completo: false,
    }

    // Verificar se est√° completo
    dados.completo = !!(dados.nome && dados.servico && dados.data && dados.horario)

    console.log(`üìã [AI-SERVICE] Dados extra√≠dos:`, dados)
    return dados
  }

  private extrairNome(message: string): string | null {
    // Tentar extrair nome de frases como "meu nome √© Jo√£o", "sou o Pedro", etc.
    const patterns = [
      /(?:meu nome √©|me chamo|sou o?a?)\s+([a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+)/i,
      /^([a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß]+(?:\s+[a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß]+)*)\s+(?:aqui|falando)/i,
      /nome(?:\s+√©)?(?:\s+do)?(?:\s+cliente)?(?:\s+)?:?\s+([a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+)/i,
    ]

    for (const pattern of patterns) {
      const match = message.match(pattern)
      if (match && match[1]) {
        const nome = match[1].trim()
        // Verificar se o nome tem pelo menos 3 caracteres e n√£o √© apenas uma palavra comum
        if (nome.length >= 3 && !["sim", "n√£o", "nao", "ok", "bom", "bem"].includes(nome.toLowerCase())) {
          return nome
        }
      }
    }

    // Tentar extrair um nome pr√≥prio da mensagem (primeira palavra com mai√∫scula)
    const palavras = message.split(/\s+/)
    for (const palavra of palavras) {
      if (palavra.length >= 3 && /^[A-Z√Å√Ä√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß]+$/.test(palavra)) {
        return palavra
      }
    }

    return null
  }

  private extrairServico(message: string, servicos: ServicoConfigurado[]): string | null {
    const lowerMessage = message.toLowerCase()

    console.log(`üîç [AI-SERVICE] Extraindo servi√ßo de: "${message}"`)
    console.log(
      `üîç [AI-SERVICE] Servi√ßos dispon√≠veis:`,
      servicos.map((s) => s.nome),
    )

    for (const servico of servicos) {
      if (lowerMessage.includes(servico.nome.toLowerCase())) {
        console.log(`‚úÖ [AI-SERVICE] Servi√ßo encontrado: ${servico.nome}`)
        return servico.nome
      }
    }

    // Palavras-chave gen√©ricas
    if (lowerMessage.includes("corte") || lowerMessage.includes("cabelo")) {
      const corte = servicos.find(
        (s) => s.nome.toLowerCase().includes("corte") || s.nome.toLowerCase().includes("cabelo"),
      )
      if (corte) {
        console.log(`‚úÖ [AI-SERVICE] Servi√ßo encontrado por palavra-chave: ${corte.nome}`)
        return corte.nome
      }
    }

    if (lowerMessage.includes("barba")) {
      const barba = servicos.find((s) => s.nome.toLowerCase().includes("barba"))
      if (barba) {
        console.log(`‚úÖ [AI-SERVICE] Servi√ßo encontrado por palavra-chave: ${barba.nome}`)
        return barba.nome
      }
    }

    console.log(`‚ùå [AI-SERVICE] Nenhum servi√ßo encontrado na mensagem`)
    return null
  }

  private extrairData(message: string): string | null {
    const hoje = dayjs()
    const lowerMessage = message.toLowerCase()

    console.log(`üîç [AI-SERVICE] Extraindo data de: "${message}"`)

    if (lowerMessage.includes("hoje")) {
      console.log(`‚úÖ [AI-SERVICE] Data encontrada: hoje`)
      return hoje.format("YYYY-MM-DD")
    }

    if (lowerMessage.includes("amanh√£") || lowerMessage.includes("amanha")) {
      console.log(`‚úÖ [AI-SERVICE] Data encontrada: amanh√£`)
      return hoje.add(1, "day").format("YYYY-MM-DD")
    }

    // Formato DD/MM
    const regexData = /(\d{1,2})\/(\d{1,2})/
    const match = message.match(regexData)
    if (match) {
      const dia = Number.parseInt(match[1]!)
      const mes = Number.parseInt(match[2]!)
      const ano = hoje.year()

      try {
        const data = dayjs(`${ano}-${mes.toString().padStart(2, "0")}-${dia.toString().padStart(2, "0")}`)
        if (data.isValid() && data.isAfter(hoje.subtract(1, "day"))) {
          console.log(`‚úÖ [AI-SERVICE] Data encontrada: ${data.format("DD/MM/YYYY")}`)
          return data.format("YYYY-MM-DD")
        }
      } catch {
        console.log(`‚ùå [AI-SERVICE] Data inv√°lida: ${dia}/${mes}`)
        return null
      }
    }

    console.log(`‚ùå [AI-SERVICE] Nenhuma data encontrada na mensagem`)
    return null
  }

  private extrairHorario(message: string): string | null {
    console.log(`üîç [AI-SERVICE] Extraindo hor√°rio de: "${message}"`)

    // Padr√µes mais flex√≠veis para hor√°rio
    const patterns = [
      /(\d{1,2}):(\d{2})/, // 14:30
      /(\d{1,2})h(\d{2})/, // 14h30
      /(\d{1,2})h/, // 14h
      /as\s+(\d{1,2})/, // as 14
      /(\d{1,2})\s*horas?/, // 14 horas
    ]

    for (const pattern of patterns) {
      const match = message.match(pattern)
      if (match) {
        const hora = match[1]!.padStart(2, "0")
        const minuto = match[2] ? match[2] : "00"
        const horarioFormatado = `${hora}:${minuto}`
        console.log(`‚úÖ [AI-SERVICE] Hor√°rio encontrado: ${horarioFormatado}`)
        return horarioFormatado
      }
    }

    console.log(`‚ùå [AI-SERVICE] Nenhum hor√°rio encontrado na mensagem`)
    return null
  }

  private createNaturalQuestion(dados: any): string {
    const faltantes = []

    if (!dados.nome) faltantes.push("seu nome completo")
    if (!dados.servico) faltantes.push("qual servi√ßo voc√™ quer")
    if (!dados.data) faltantes.push("que dia prefere")
    if (!dados.horario) faltantes.push("qual hor√°rio")

    if (faltantes.length === 1) {
      return `Perfeito! S√≥ preciso saber ${faltantes[0]} pra finalizar seu agendamento. üòä`
    } else {
      return `√ìtimo! Pra agendar, preciso saber ${faltantes.slice(0, -1).join(", ")} e ${faltantes[faltantes.length - 1]}. Pode me falar?`
    }
  }

  private formatarServicosNatural(servicos: ServicoConfigurado[]): string {
    if (servicos.length === 0) {
      return "Opa! Nossos servi√ßos principais s√£o corte, barba e corte + barba. Qual te interessa? üòä"
    }

    let texto = "Nossos servi√ßos s√£o:\n\n"
    servicos.forEach((servico, index) => {
      texto += `${index + 1}. **${servico.nome}** - R$ ${servico.preco.toFixed(2)} (${servico.duracaoMinutos} min)\n`
    })
    texto += "\nQual voc√™ gostaria de agendar? üíà"
    return texto
  }

  private formatarAgendamentosNatural(agendamentos: any[]): string {
    if (agendamentos.length === 0) {
      return "Voc√™ ainda n√£o tem agendamentos comigo. Quer marcar um? üòä"
    }

    let texto = "Seus agendamentos:\n\n"
    agendamentos.forEach((agendamento, index) => {
      const data = dayjs(agendamento.dataHora)
      const status = agendamento.status === "agendado" ? "‚úÖ" : agendamento.status === "concluido" ? "‚úîÔ∏è" : "‚ùå"
      texto += `${status} **${agendamento.servico}** - ${data.format("DD/MM")} √†s ${data.format("HH:mm")}\n`
    })

    return texto
  }

  private isPrimeiraMensagemDaConversa(
    telefone: string,
    conversationHistory: Array<{ role: string; content: string }>,
  ): boolean {
    // Se j√° fizemos a sauda√ß√£o para este telefone, n√£o √© primeira mensagem
    if (this.saudacoesFeitas.has(telefone)) {
      return false
    }

    // Se n√£o h√° hist√≥rico ou h√° apenas 1 mensagem (a atual), √© primeira mensagem
    return conversationHistory.length <= 1
  }

  private async criarSaudacaoPersonalizada(cliente: any, mensagemUsuario: string): Promise<string | null> {
    try {
      console.log(`üëã [AI-SERVICE] Criando sauda√ß√£o personalizada para:`, cliente?.nome || "cliente n√£o cadastrado")

      // Determinar o tipo de sauda√ß√£o baseado na mensagem do usu√°rio
      const tipoSaudacao = this.determinarTipoSaudacao(mensagemUsuario)

      if (cliente && cliente.nome) {
        // Cliente cadastrado - usar primeiro nome
        const primeiroNome = this.extrairPrimeiroNome(cliente.nome)
        console.log(`‚úÖ [AI-SERVICE] Cliente cadastrado: ${cliente.nome} -> Primeiro nome: ${primeiroNome}`)

        return this.gerarSaudacaoComNome(primeiroNome, tipoSaudacao, mensagemUsuario)
      } else {
        // Cliente n√£o cadastrado - sauda√ß√£o gen√©rica
        console.log(`üÜï [AI-SERVICE] Cliente n√£o cadastrado - sauda√ß√£o gen√©rica`)

        return this.gerarSaudacaoGenerica(tipoSaudacao, mensagemUsuario)
      }
    } catch (error) {
      console.error("üí• [AI-SERVICE] Erro ao criar sauda√ß√£o personalizada:", error)
      return null
    }
  }

  private extrairPrimeiroNome(nomeCompleto: string): string {
    // Extrair apenas o primeiro nome
    const nomes = nomeCompleto.trim().split(/\s+/)
    const primeiroNome = nomes[0] || nomeCompleto

    // Capitalizar primeira letra
    return primeiroNome.charAt(0).toUpperCase() + primeiroNome.slice(1).toLowerCase()
  }

  private determinarTipoSaudacao(mensagem: string): "formal" | "casual" | "urgente" | "servico" {
    const lowerMessage = mensagem.toLowerCase()

    // Detectar urg√™ncia
    if (lowerMessage.includes("urgente") || lowerMessage.includes("r√°pido") || lowerMessage.includes("agora")) {
      return "urgente"
    }

    // Detectar pedido direto de servi√ßo
    if (
      lowerMessage.includes("agendar") ||
      lowerMessage.includes("marcar") ||
      lowerMessage.includes("corte") ||
      lowerMessage.includes("barba")
    ) {
      return "servico"
    }

    // Detectar sauda√ß√µes formais
    if (lowerMessage.includes("bom dia") || lowerMessage.includes("boa tarde") || lowerMessage.includes("boa noite")) {
      return "formal"
    }

    // Padr√£o casual
    return "casual"
  }

  private gerarSaudacaoComNome(primeiroNome: string, tipo: string, mensagemOriginal: string): string {
    const saudacoes = {
      formal: [
        `Ol√° ${primeiroNome}! Tudo bem? üòä`,
        `Oi ${primeiroNome}! Como voc√™ est√°?`,
        `${primeiroNome}! Que bom te ver por aqui! üòä`,
      ],
      casual: [
        `E a√≠ ${primeiroNome}! Tudo certo? üòÑ`,
        `Opa ${primeiroNome}! Beleza?`,
        `Ol√° ${primeiroNome}! Tudo bem? üòä`,
      ],
      urgente: [`Oi ${primeiroNome}! Vou te ajudar rapidinho! üöÄ`, `${primeiroNome}! Estou aqui pra te atender! üòä`],
      servico: [
        `Ol√° ${primeiroNome}! Vamos agendar seu hor√°rio? üíà`,
        `Oi ${primeiroNome}! Que bom que voc√™ voltou! üòä`,
      ],
    }

    const opcoes = saudacoes[tipo] || saudacoes.casual
    const saudacaoEscolhida = opcoes[Math.floor(Math.random() * opcoes.length)]

    // Adicionar pergunta contextual baseada na mensagem
    let perguntaContextual = ""

    if (tipo === "servico") {
      perguntaContextual = " O que voc√™ gostaria de agendar hoje?"
    } else if (tipo === "urgente") {
      perguntaContextual = " Em que posso te ajudar?"
    } else {
      perguntaContextual = " Como posso te ajudar hoje?"
    }

    return saudacaoEscolhida + perguntaContextual
  }

  private gerarSaudacaoGenerica(tipo: string, mensagemOriginal: string): string {
    const saudacoes = {
      formal: [`Ol√°! Tudo bem? üòä`, `Oi! Como voc√™ est√°?`, `Ol√°! Que bom ter voc√™ aqui! üòä`],
      casual: [`E a√≠! Tudo certo? üòÑ`, `Opa! Beleza?`, `Ol√°! Tudo bem? üòä`],
      urgente: [`Oi! Vou te ajudar rapidinho! üöÄ`, `Ol√°! Estou aqui pra te atender! üòä`],
      servico: [`Ol√°! Vamos agendar seu hor√°rio? üíà`, `Oi! Bem-vindo √† nossa barbearia! üòä`],
    }

    const opcoes = saudacoes[tipo] || saudacoes.casual
    const saudacaoEscolhida = opcoes[Math.floor(Math.random() * opcoes.length)]

    // Adicionar pergunta contextual
    let perguntaContextual = ""

    if (tipo === "servico") {
      perguntaContextual = " O que voc√™ gostaria de agendar hoje?"
    } else if (tipo === "urgente") {
      perguntaContextual = " Em que posso te ajudar?"
    } else {
      // Para clientes novos, perguntar o nome
      perguntaContextual = " Para come√ßar, qual √© o seu nome?"
    }

    return saudacaoEscolhida + perguntaContextual
  }
}

export const aiService = new AIService()
